-- Luma UI Library
-- Smooth, animated, mobile-friendly UI library for Roblox scripts
-- Author: generated / adapted for user

local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local Luma = {}
Luma.__index = Luma

-- Default theme
Luma.Theme = {
	Background = Color3.fromRGB(20,20,25),
	Accent = Color3.fromRGB(98, 0, 238),
	PrimaryText = Color3.fromRGB(235,235,235),
	SecondaryText = Color3.fromRGB(170,170,170),
	WindowCorner = UDim.new(0, 10),
}

-- Global animation settings
Luma.Anim = {
	OpenTime = 0.36,
	CloseTime = 0.28,
	HoverTime = 0.12,
	EntryStagger = 0.04,
	ButtonPress = 0.06,
	SliderTween = 0.14,
	ToggleTime = 0.18,
}

-- Optional UI sounds (configure with asset IDs)
Luma.Sounds = {
	Enabled = false,
	ButtonClick = nil,
	ToggleFlip = nil,
	SliderGrab = nil,
	DropdownOpen = nil,
	NotifyShow = nil,
	ModalOpen = nil,
}

local function playSound(soundName)
	if not Luma.Sounds.Enabled then return end
	local soundId = Luma.Sounds[soundName]
	if not soundId then return end
	pcall(function()
		local sound = Instance.new("Sound")
		sound.SoundId = soundId
		sound.Volume = 0.5
		sound.Parent = game:GetService("SoundService") or workspace
		sound:Play()
		game:GetService("Debris"):AddItem(sound, 0.5)
	end)
end

-- Helpers
local function tween(inst, props, time, style, dir)
	style = style or Enum.EasingStyle.Quint
	dir = dir or Enum.EasingDirection.Out
	local info = TweenInfo.new(time or 0.25, style, dir)
	local t = TweenService:Create(inst, info, props)
	t:Play()
	return t
end

local function make(class, props)
	local inst = Instance.new(class)
	if props then
		for k,v in pairs(props) do
			inst[k] = v
		end
	end
	return inst
end

-- Visual & animation helpers
local function createRipple(parent, position, color)
	local rip = make("Frame", {Size = UDim2.new(0,8,0,8), AnchorPoint = Vector2.new(0.5,0.5), Position = position, BackgroundColor3 = color or Color3.fromRGB(255,255,255), BackgroundTransparency = 0.6, Parent = parent})
	make("UICorner", {Parent = rip, CornerRadius = UDim.new(1,0)})
	rip.ZIndex = parent.ZIndex + 1
	tween(rip, {Size = UDim2.new(0,200,0,200), BackgroundTransparency = 1}, 0.6, Enum.EasingStyle.Quint, Enum.EasingDirection.Out)
	task.delay(0.6, function() if rip and rip.Parent then rip:Destroy() end end)
end

local function addHoverEffects(btn)
	if not btn then return end
	btn.MouseEnter:Connect(function()
		pcall(function() tween(btn, {TextColor3 = Luma.Theme.Accent}, Luma.Anim.HoverTime, Enum.EasingStyle.Quad) end)
	end)
	btn.MouseLeave:Connect(function()
		pcall(function() tween(btn, {TextColor3 = Luma.Theme.PrimaryText}, Luma.Anim.HoverTime, Enum.EasingStyle.Quad) end)
	end)
end

local function smoothSetSize(inst, prop, target, time)
	-- prop is a table of properties
	return tween(inst, prop, time or 0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
end

-- Create root ScreenGui
function Luma:Create(name)
	local self = setmetatable({}, Luma)
	self.Name = name or "LumaUI"
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = self.Name
	screenGui.ResetOnSpawn = false
	screenGui.DisplayOrder = 999
	local targetParent = game:GetService("CoreGui")
	if not RunService:IsStudio() then
		local players = game:GetService("Players"):GetPlayers()
		if players and #players > 0 and players[1]:FindFirstChild("PlayerGui") then
			targetParent = players[1].PlayerGui
		end
	end
	screenGui.Parent = targetParent
	self.ScreenGui = screenGui

	-- Main window frame
	local main = make("Frame", {
		Name = "MainWindow",
		BackgroundColor3 = Luma.Theme.Background,
		AnchorPoint = Vector2.new(0.5,0.5),
		Position = UDim2.new(0.5,0.5,0.5,0),
		Size = UDim2.new(0,800,0,520),
		Visible = true,
		Parent = screenGui,
		ClipsDescendants = true,
	})

	local uicorner = make("UICorner", {CornerRadius = Luma.Theme.WindowCorner, Parent = main})
	-- subtle shadow behind main
	local shadow = make("Frame", {Name = "Shadow", BackgroundColor3 = Color3.fromRGB(0,0,0), AnchorPoint = Vector2.new(0.5,0.5), Position = main.Position, Size = UDim2.new(main.Size.X.Scale, main.Size.X.Offset + 12, main.Size.Y.Scale, main.Size.Y.Offset + 12), BackgroundTransparency = 0.9, Parent = screenGui})
	make("UICorner", {Parent = shadow, CornerRadius = Luma.Theme.WindowCorner})
	shadow.ZIndex = main.ZIndex - 1
	local titlebar = make("Frame", {Name = "TitleBar", BackgroundTransparency = 1, Size = UDim2.new(1,0,0,40), Parent = main})
	local titlebarGradient = make("UIGradient", {Parent = titlebar})
	titlebarGradient.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Luma.Theme.Background), ColorSequenceKeypoint.new(1, Luma.Theme.Background:Lerp(Luma.Theme.Accent, 0.06))})
	make("UIStroke", {Parent = titlebar, Color = Luma.Theme.Accent, Transparency = 0.9, Thickness = 1})
	local title = make("TextLabel", {Name = "Title", BackgroundTransparency = 1, Text = name or "Luma UI", TextColor3 = Luma.Theme.PrimaryText, Font = Enum.Font.GothamBold, TextSize = 18, Position = UDim2.new(0,16,0,8), Parent = titlebar})

	-- Toggle button
	local toggleBtn = make("TextButton", {Name = "Toggle", BackgroundTransparency = 1, Text = "-", TextColor3 = Luma.Theme.SecondaryText, Font = Enum.Font.Gotham, TextSize = 20, Size = UDim2.new(0,40,0,40), Position = UDim2.new(1,-44,0,0), Parent = titlebar})
	-- Window controls: minimize, maximize, close
	local maxBtn = make("TextButton", {Name = "Maximize", BackgroundTransparency = 1, Text = "□", TextColor3 = Luma.Theme.SecondaryText, Font = Enum.Font.Gotham, TextSize = 16, Size = UDim2.new(0,40,0,40), Position = UDim2.new(1,-88,0,0), Parent = titlebar})
	local closeBtn = make("TextButton", {Name = "Close", BackgroundTransparency = 1, Text = "×", TextColor3 = Luma.Theme.SecondaryText, Font = Enum.Font.GothamBold, TextSize = 20, Size = UDim2.new(0,40,0,40), Position = UDim2.new(1,-132,0,0), Parent = titlebar})

	self.Main = main
	self.Title = title
	self.Tabs = {}

	-- Body
	local body = make("Frame", {Name = "Body", BackgroundTransparency = 1, Size = UDim2.new(1,0,1,-40), Position = UDim2.new(0,0,0,40), Parent = main})
	local left = make("Frame", {Name = "Left", BackgroundTransparency = 1, Size = UDim2.new(0,200,1,0), Parent = body})

	-- global toggle hotkey (RightControl by default)
	local toggleKey = Enum.KeyCode.RightControl
	local bound = false
	local function onInputBegan(i, gp)
		if gp then return end
		if i.KeyCode == toggleKey then
			bound = not bound
			tween(main, {Size = bound and UDim2.new(0,800,0,520) or UDim2.new(0,40,0,40)}, 0.28)
		end
	end
	UserInputService.InputBegan:Connect(onInputBegan)

	local right = make("Frame", {Name = "Right", BackgroundTransparency = 1, Size = UDim2.new(1,-200,1,0), Position = UDim2.new(0,200,0,0), Parent = body})

	local leftList = make("UIListLayout", {Parent = left})
	leftList.SortOrder = Enum.SortOrder.LayoutOrder

	self.Left = left
	self.Right = right

	-- Tabs container (buttons)
	local tabs = make("Frame", {Name = "Tabs", BackgroundTransparency = 1, Size = UDim2.new(1,0,0,40), Parent = left})
	local tabsLayout = make("UIListLayout", {Parent = tabs, FillDirection = Enum.FillDirection.Horizontal, SortOrder = Enum.SortOrder.LayoutOrder, HorizontalAlignment = Enum.HorizontalAlignment.Left})

	-- Sections scroller
	local content = make("ScrollingFrame", {Name = "Content", BackgroundTransparency = 1, Size = UDim2.new(1,1,1,-40), Position = UDim2.new(0,0,0,40), Parent = right, ScrollBarThickness = 6, CanvasSize = UDim2.new(0,0,0,0)})
	content.AutomaticCanvasSize = Enum.AutomaticSize.Y
	local contentLayout = make("UIListLayout", {Parent = content, Padding = UDim.new(0,8)})

	self.TabsFrame = tabs
	self.Content = content

	-- Toggle behavior
	local shown = true
	-- initial pop animation for smooth entrance
	do
		local targetSize = main.Size
		main.Size = UDim2.new(targetSize.X.Scale, math.floor(targetSize.X.Offset * 0.94), targetSize.Y.Scale, math.floor(targetSize.Y.Offset * 0.94))
		main.BackgroundTransparency = 1
		tween(main, {Size = targetSize, BackgroundTransparency = 0}, Luma.Anim.OpenTime, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
	end

	toggleBtn.MouseButton1Click:Connect(function()
		shown = not shown
		if shown then
			tween(main, {Size = UDim2.new(0,800,0,520)}, Luma.Anim.OpenTime, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
			tween(main, {BackgroundTransparency = 0}, Luma.Anim.OpenTime)
			toggleBtn.Text = "-"
		else
			tween(main, {Size = UDim2.new(0,40,0,40)}, Luma.Anim.CloseTime, Enum.EasingStyle.Sine, Enum.EasingDirection.In)
			tween(main, {BackgroundTransparency = 0.95}, Luma.Anim.CloseTime)
			toggleBtn.Text = "+"
		end
	end)

	-- Make draggable by TitleBar
	local dragging, dragStart, startPos
	local isMaximized = false
	local prevSize, prevPos
	titlebar.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = main.Position
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end)
	titlebar.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			if dragging and dragStart and startPos then
				local delta = input.Position - dragStart
				main.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
			end
		end
	end)

	-- Double-click titlebar to toggle maximize/restore
	local lastClick = 0
	titlebar.InputBegan:Connect(function(inp)
		if inp.UserInputType == Enum.UserInputType.MouseButton1 then
			local now = tick()
			if now - lastClick < 0.35 then
				-- toggle maximize
				if not isMaximized then
					prevSize = main.Size
					prevPos = main.Position
					isMaximized = true
					tween(main, {Size = UDim2.new(1, -40, 1, -80), Position = UDim2.new(0,20,0,40)}, Luma.Anim.OpenTime, Enum.EasingStyle.Back)
				else
					isMaximized = false
					tween(main, {Size = prevSize, Position = prevPos}, Luma.Anim.CloseTime, Enum.EasingStyle.Sine)
				end
			end
			lastClick = now
		end
	end)

	-- Maximize and Close button actions
	maxBtn.MouseButton1Click:Connect(function()
		if not isMaximized then
			prevSize = main.Size
			prevPos = main.Position
			isMaximized = true
			tween(main, {Size = UDim2.new(1, -40, 1, -80), Position = UDim2.new(0,20,0,40)}, Luma.Anim.OpenTime, Enum.EasingStyle.Back)
			maxBtn.Text = "❐"
		else
			isMaximized = false
			tween(main, {Size = prevSize or UDim2.new(0,800,0,520), Position = prevPos or UDim2.new(0.5,0,0.5,0)}, Luma.Anim.CloseTime, Enum.EasingStyle.Sine)
			maxBtn.Text = "□"
		end
	end)

	closeBtn.MouseButton1Click:Connect(function()
		-- destroy the GUI
		if self and self.ScreenGui then
			self.ScreenGui:Destroy()
			self.ScreenGui = nil
			self.Main = nil
		end
	end)

	-- Responsive: adjust sizing for mobile
	if UserInputService.TouchEnabled then
		main.Size = UDim2.new(0,640,0,440)
		main.Position = UDim2.new(0.5,0,0.5,0)
	end

	return self
end

-- Add Tab
function Luma:AddTab(title)
	local tabBtn = make("TextButton", {Text = title, BackgroundTransparency = 1, TextColor3 = Luma.Theme.PrimaryText, Font = Enum.Font.Gotham, TextSize = 16, Size = UDim2.new(0,120,1,0), Parent = self.TabsFrame})
    addHoverEffects(tabBtn)
	local tabContent = make("Frame", {Name = title.."Section", BackgroundTransparency = 1, Size = UDim2.new(1,0,0,0), Parent = self.Content})
	local layout = make("UIListLayout", {Parent = tabContent, Padding = UDim.new(0,8)})

	-- click behavior: show only this tab's content
		tabBtn.MouseButton1Click:Connect(function()
			-- animate hide current visible frames and show this one with a slide/fade
			for _, child in pairs(self.Content:GetChildren()) do
				if child:IsA("Frame") and child.Visible then
					-- slide out
					child.Visible = true
					child.ClipsDescendants = true
					for _, c in pairs(child:GetChildren()) do
						if c:IsA("Frame") or c:IsA("TextLabel") or c:IsA("ScrollingFrame") then
							pcall(function() tween(c, {Position = UDim2.new(c.Position.X.Scale, c.Position.X.Offset - 20, c.Position.Y.Scale, c.Position.Y.Offset), }, 0.18) end)
							pcall(function() tween(c, {TextTransparency = 1}, 0.18) end)
						end
					end
					child.Visible = false
				end
			end
			-- prepare new content
			tabContent.Visible = true
			for _, c in pairs(tabContent:GetChildren()) do
				if c:IsA("Frame") or c:IsA("TextLabel") or c:IsA("ScrollingFrame") then
					pcall(function()
						c.Position = UDim2.new(c.Position.X.Scale, c.Position.X.Offset + 20, c.Position.Y.Scale, c.Position.Y.Offset)
						c.TextTransparency = 1
					end)
				end
			end
			-- animate in
			task.delay(0.02, function()
				for _, c in pairs(tabContent:GetChildren()) do
					if c:IsA("Frame") or c:IsA("TextLabel") or c:IsA("ScrollingFrame") then
						pcall(function() tween(c, {Position = UDim2.new(c.Position.X.Scale, c.Position.X.Offset - 20, c.Position.Y.Scale, c.Position.Y.Offset), }, 0.28, Enum.EasingStyle.Quad) end)
						pcall(function() tween(c, {TextTransparency = 0}, 0.28, Enum.EasingStyle.Quad) end)
					end
				end
			end)
		end)

	-- default: hide new tab content and show first if none
	if not next(self.Tabs) then
		tabContent.Visible = true
	else
		tabContent.Visible = false
	end

	local tab = {
		Title = title,
		Button = tabBtn,
		Content = tabContent,
	}
	table.insert(self.Tabs, tab)

	-- section builder
	function tab:AddSection(name)
		local section = make("Frame", {Name = name, BackgroundTransparency = 1, Size = UDim2.new(1, -16, 0, 40), Parent = tabContent})
		local header = make("TextLabel", {Text = name, BackgroundTransparency = 1, TextColor3 = Luma.Theme.PrimaryText, Font = Enum.Font.GothamBold, TextSize = 14, Position = UDim2.new(0,8,0,0), Parent = section})
		local items = make("Frame", {Name = "Items", BackgroundTransparency = 1, Position = UDim2.new(0,0,0,24), Size = UDim2.new(1,0,0,0), Parent = section})
		local list = make("UIListLayout", {Parent = items})
		items.AutomaticSize = Enum.AutomaticSize.Y
		section.AutomaticSize = Enum.AutomaticSize.Y

		function items:AddButton(text, callback)
			local b = make("TextButton", {Text = text, BackgroundTransparency = 0, BackgroundColor3 = Color3.fromRGB(30,30,35), TextColor3 = Luma.Theme.PrimaryText, Font = Enum.Font.Gotham, TextSize = 14, Size = UDim2.new(1, -16, 0, 36), Parent = items, AutoButtonColor = false})
			local corner = make("UICorner", {Parent = b, CornerRadius = UDim.new(0,6)})
			local stroke = make("UIStroke", {Parent = b, Color = Color3.fromRGB(0,0,0), Transparency = 0.7, Thickness = 1})
			addHoverEffects(b)
			b.MouseButton1Click:Connect(function(input)
				playSound("ButtonClick")
				-- ripple effect at mouse location
				local pos = UDim2.new(0, b.AbsoluteSize.X/2, 0, b.AbsoluteSize.Y/2)
				local mousePos = UserInputService:GetMouseLocation()
				local relativeX = mousePos.X - b.AbsolutePosition.X
				local relativeY = mousePos.Y - b.AbsolutePosition.Y
				if relativeX and relativeY then pos = UDim2.new(0, relativeX, 0, relativeY) end
				createRipple(b, pos, Luma.Theme.Accent)
				-- press animation
				tween(b, {Size = UDim2.new(1, -16, 0, 34)}, Luma.Anim.ButtonPress, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
				task.delay(Luma.Anim.ButtonPress, function()
					tween(b, {Size = UDim2.new(1, -16, 0, 36)}, Luma.Anim.ButtonPress * 2.3, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out)
				end)
				if callback then pcall(callback) end
			end)
			return b
		end

		function items:AddToggle(text, default, callback)
			local wrap = make("Frame", {Size = UDim2.new(1,-16,0,36), BackgroundTransparency = 1, Parent = items})
			local label = make("TextLabel", {Text = text, BackgroundTransparency = 1, TextColor3 = Luma.Theme.PrimaryText, Font = Enum.Font.Gotham, TextSize = 14, Position = UDim2.new(0,8,0,8), Parent = wrap})
			local toggleBg = make("Frame", {Size = UDim2.new(0,46,0,24), Position = UDim2.new(1,-56,0,6), BackgroundColor3 = Color3.fromRGB(60,60,65), Parent = wrap})
			local tcorner = make("UICorner", {Parent = toggleBg, CornerRadius = UDim.new(0,12)})
			local thumb = make("Frame", {Size = UDim2.new(0,20,0,20), Position = UDim2.new(default and 1 or 0, 4, 0, 2), BackgroundColor3 = default and Luma.Theme.Accent or Color3.fromRGB(220,220,220), Parent = toggleBg})
			make("UICorner", {Parent = thumb, CornerRadius = UDim.new(1,0)})
			addHoverEffects(toggleBg)

			local isOn = default
			local function setState(v)
				isOn = v
				if isOn then
					tween(thumb, {Position = UDim2.new(1, -24, 0, 2)}, 0.18, Enum.EasingStyle.Quint)
					tween(toggleBg, {BackgroundColor3 = Color3.fromRGB(40,40,45)}, 0.18)
					tween(thumb, {BackgroundColor3 = Luma.Theme.Accent}, 0.18)
				else
					tween(thumb, {Position = UDim2.new(0, 4, 0, 2)}, 0.18, Enum.EasingStyle.Quint)
					tween(toggleBg, {BackgroundColor3 = Color3.fromRGB(60,60,65)}, 0.18)
					tween(thumb, {BackgroundColor3 = Color3.fromRGB(220,220,220)}, 0.18)
				end
				if callback then pcall(callback, isOn) end
			end

			toggleBg.InputBegan:Connect(function(inp)
				if inp.UserInputType == Enum.UserInputType.MouseButton1 or inp.UserInputType == Enum.UserInputType.Touch then
					playSound("ToggleFlip")
					setState(not isOn)
				end
			end)

			setState(isOn)
			return {Set = setState, Get = function() return isOn end}
		end

		function items:AddSlider(text, min, max, default, callback)
			local wrap = make("Frame", {Size = UDim2.new(1,-16,0,56), BackgroundTransparency = 1, Parent = items})
			local label = make("TextLabel", {Text = text.." — "..tostring(default), BackgroundTransparency = 1, TextColor3 = Luma.Theme.PrimaryText, Font = Enum.Font.Gotham, TextSize = 14, Position = UDim2.new(0,8,0,6), Parent = wrap})
			local sliderBg = make("Frame", {BackgroundColor3 = Color3.fromRGB(40,40,45), Size = UDim2.new(1, -16, 0, 12), Position = UDim2.new(0,8,0,30), Parent = wrap})
			make("UICorner", {Parent = sliderBg, CornerRadius = UDim.new(0,6)})
			local fill = make("Frame", {BackgroundColor3 = Luma.Theme.Accent, Size = UDim2.new( (default-min)/(max-min), 0, 1, 0), Parent = sliderBg})
			make("UICorner", {Parent = fill, CornerRadius = UDim.new(0,6)})
			local grab = make("ImageButton", {Size = UDim2.new(0,18,0,18), Position = UDim2.new(fill.Size.X.Scale, -9, 0.5, -9), BackgroundTransparency = 1, Parent = sliderBg, Image = "rbxassetid://3926307971", ImageColor3 = Color3.fromRGB(255,255,255)})

			local function updateFromX(x)
				local relative = math.clamp((x - sliderBg.AbsolutePosition.X)/sliderBg.AbsoluteSize.X, 0, 1)
				local value = min + (max-min) * relative
				label.Text = text.." — "..string.format("%.2f", value)
				-- smooth animate fill and grab
				tween(fill, {Size = UDim2.new(relative, 0, 1, 0)}, Luma.Anim.SliderTween, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
				tween(grab, {Position = UDim2.new(relative, -9, 0.5, -9)}, Luma.Anim.SliderTween, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
				if callback then pcall(callback, value) end
			end

			local dragging = false
			grab.InputBegan:Connect(function(inp)
				if inp.UserInputType == Enum.UserInputType.MouseButton1 or inp.UserInputType == Enum.UserInputType.Touch then
					dragging = true
					playSound("SliderGrab")
					-- grab press animation
					tween(grab, {Size = UDim2.new(0,22,0,22)}, Luma.Anim.ButtonPress, Enum.EasingStyle.Quad)
				end
			end)
			grab.InputEnded:Connect(function(inp)
				if inp.UserInputType == Enum.UserInputType.MouseButton1 or inp.UserInputType == Enum.UserInputType.Touch then
					dragging = false
					-- release animation back to normal
					tween(grab, {Size = UDim2.new(0,18,0,18)}, Luma.Anim.ButtonPress * 1.4, Enum.EasingStyle.Elastic)
				end
			end)
			UserInputService.InputChanged:Connect(function(i)
				if dragging and (i.UserInputType == Enum.UserInputType.MouseMovement or i.UserInputType == Enum.UserInputType.Touch) then
					updateFromX(i.Position.X)
				end
			end)

			return {Fill = fill, Grab = grab}
		end

		function items:AddTextbox(placeholder, callback)
			local box = make("TextBox", {Text = "", PlaceholderText = placeholder or "", BackgroundColor3 = Color3.fromRGB(30,30,35), TextColor3 = Luma.Theme.PrimaryText, Font = Enum.Font.Gotham, TextSize = 14, Size = UDim2.new(1, -16, 0, 32), Parent = items})
			local corner = make("UICorner", {Parent = box, CornerRadius = UDim.new(0,6)})
			box.FocusLost:Connect(function(enter)
				if enter then
					if callback then pcall(callback, box.Text) end
				end
			end)
			return box
		end

		-- Dropdown (simple)
		-- Enhanced Dropdown: options (table), default, callback, opts: {multi = bool, search = bool}
		function items:AddDropdown(text, options, default, callback, opts)
			options = options or {}
			opts = opts or {}
			local multi = opts.multi or false
			local enableSearch = opts.search or false
			local selected = {}
			if not multi then
				selected.value = default or options[1]
			end

			local wrap = make("Frame", {Size = UDim2.new(1,-16,0,36), BackgroundTransparency = 1, Parent = items})
			local label = make("TextLabel", {Text = text, BackgroundTransparency = 1, TextColor3 = Luma.Theme.PrimaryText, Font = Enum.Font.Gotham, TextSize = 14, Position = UDim2.new(0,8,0,6), Parent = wrap})
			local btn = make("TextButton", {Text = (multi and "Select..." or tostring(selected.value)), Size = UDim2.new(0,160,0,24), Position = UDim2.new(1,-168,0,6), BackgroundColor3 = Color3.fromRGB(34,34,38), TextColor3 = Luma.Theme.PrimaryText, Parent = wrap})
			make("UICorner", {Parent = btn, CornerRadius = UDim.new(0,6)})

			local list = make("Frame", {Size = UDim2.new(0,160,0,0), Position = UDim2.new(1,-168,0,46), BackgroundColor3 = Color3.fromRGB(30,30,35), Parent = wrap, ClipsDescendants = true, Visible = false})
			local listLayout = make("UIListLayout", {Parent = list})

			local entries = {}
			local visibleOptions = {}

			local function refreshList(filter)
				for i,v in ipairs(entries) do v:Destroy() end
				entries = {}
				visibleOptions = {}
				for i,opt in ipairs(options) do
					if not filter or string.find(string.lower(tostring(opt)), string.lower(filter)) then
						table.insert(visibleOptions, opt)
						local optBtn = make("TextButton", {Text = tostring(opt), Size = UDim2.new(1,0,0,28), BackgroundTransparency = 1, TextColor3 = Luma.Theme.PrimaryText, Parent = list})
						if multi then
							local marker = make("TextLabel", {Text = "", Size = UDim2.new(0,24,1,0), Position = UDim2.new(1,-28,0,0), BackgroundTransparency = 1, TextColor3 = Luma.Theme.PrimaryText, Parent = optBtn})
							local function updateMarker()
								if table.find(selected, opt) then marker.Text = "✔" else marker.Text = "" end
							end
							updateMarker()
							optBtn.MouseButton1Click:Connect(function()
								if table.find(selected, opt) then
									for idx,val in ipairs(selected) do if val == opt then table.remove(selected, idx); break end end
								else
									table.insert(selected, opt)
								end
								updateMarker()
								if callback then pcall(callback, selected) end
							end)
						else
							optBtn.MouseButton1Click:Connect(function()
								selected.value = opt
								btn.Text = tostring(selected.value)
								tween(list, {Size = UDim2.new(0,160,0,0)}, 0.18)
								task.delay(0.18, function() list.Visible = false end)
								if callback then pcall(callback, selected.value) end
							end)
						end
						table.insert(entries, optBtn)
					end
				end
					local target = #entries * 28
					list.Size = UDim2.new(0,160,0,target)
					-- prepare staggered reveal for entries
					for i,entry in ipairs(entries) do
						entry.Position = UDim2.new(0,0,0,(i-1)*28)
						entry.TextTransparency = 1
						entry.BackgroundTransparency = 1
						local delayTime = Luma.Anim.EntryStagger * (i-1)
						task.delay(delayTime, function()
							pcall(function()
								-- fade in text
								tween(entry, {TextTransparency = 0}, 0.18, Enum.EasingStyle.Quad)
								-- slight background highlight then settle
								entry.BackgroundTransparency = 0.8
								tween(entry, {BackgroundTransparency = 1}, 0.28)
							end)
						end)
					end
			end

			local searchBox
			if enableSearch then
				searchBox = make("TextBox", {PlaceholderText = "Search...", BackgroundColor3 = Color3.fromRGB(34,34,38), TextColor3 = Luma.Theme.PrimaryText, Size = UDim2.new(1,0,0,24), Parent = list})
				make("UICorner", {Parent = searchBox, CornerRadius = UDim.new(0,6)})
				searchBox:GetPropertyChangedSignal("Text"):Connect(function()
					refreshList(searchBox.Text)
				end)
			end


			local navConn
			btn.MouseButton1Click:Connect(function()
				if list.Visible then
					-- close
					if navConn then navConn:Disconnect(); navConn = nil end
					tween(list, {Size = UDim2.new(0,160,0,0)}, 0.18)
					task.delay(0.18, function() list.Visible = false end)
				else
					playSound("DropdownOpen")
					list.Visible = true
					refreshList(enableSearch and searchBox and searchBox.Text)
					local selectedIndex = 1
					local function highlight(idx)
						for i,v in ipairs(entries) do
							if i == idx then
								v.BackgroundTransparency = 0.2
							else
								v.BackgroundTransparency = 1
							end
						end
					end
					if #entries > 0 then highlight(selectedIndex) end
					-- keyboard navigation
					navConn = UserInputService.InputBegan:Connect(function(input, gp)
						if gp then return end
						if input.KeyCode == Enum.KeyCode.Down then
							selectedIndex = math.clamp(selectedIndex + 1, 1, #entries)
							highlight(selectedIndex)
						elseif input.KeyCode == Enum.KeyCode.Up then
							selectedIndex = math.clamp(selectedIndex - 1, 1, #entries)
							highlight(selectedIndex)
						elseif input.KeyCode == Enum.KeyCode.Return or input.KeyCode == Enum.KeyCode.ButtonA then
							if entries[selectedIndex] then
								entries[selectedIndex]:MouseButton1Click()
							end
						end
					end)
					tween(list, {Size = list.Size}, 0.18)
				end
			end)

			-- Public API
			return {
				Button = btn,
				Get = function()
					return multi and selected or selected.value
				end,
				Set = function(v)
					if multi then
						selected = v or {}
					else
						selected.value = v
						btn.Text = tostring(v)
					end
				end
			}
		end

		-- Keybind capture
		function items:AddKeybind(text, defaultKey, callback)
			local key = defaultKey or "None"
			local wrap = make("Frame", {Size = UDim2.new(1,-16,0,36), BackgroundTransparency = 1, Parent = items})
			local label = make("TextLabel", {Text = text, BackgroundTransparency = 1, TextColor3 = Luma.Theme.PrimaryText, Font = Enum.Font.Gotham, TextSize = 14, Position = UDim2.new(0,8,0,8), Parent = wrap})
			local keyBtn = make("TextButton", {Text = tostring(key), Size = UDim2.new(0,120,0,24), Position = UDim2.new(1,-136,0,6), BackgroundColor3 = Color3.fromRGB(34,34,38), TextColor3 = Luma.Theme.PrimaryText, Parent = wrap})
			make("UICorner", {Parent = keyBtn, CornerRadius = UDim.new(0,6)})

			local listening = false
			local conn
			keyBtn.MouseButton1Click:Connect(function()
				if listening then return end
				listening = true
				keyBtn.Text = "..."
				conn = UserInputService.InputBegan:Connect(function(i, gameProcessed)
					if gameProcessed then return end
					if i.KeyCode then
						key = tostring(i.KeyCode):gsub("Enum.KeyCode.", "")
						keyBtn.Text = key
						listening = false
						if conn then conn:Disconnect(); conn = nil end
						if callback then pcall(callback, key) end
					end
				end)
			end)

			return {Button = keyBtn, Get = function() return key end}
		end

		-- Color picker with Hue control + RGB sliders
		local function HSVToRGB(h, s, v)
			local r, g, b
			local i = math.floor(h * 6)
			local f = h * 6 - i
			local p = v * (1 - s)
			local q = v * (1 - f * s)
			local t = v * (1 - (1 - f) * s)
			i = i % 6
			if i == 0 then r, g, b = v, t, p
			elseif i == 1 then r, g, b = q, v, p
			elseif i == 2 then r, g, b = p, v, t
			elseif i == 3 then r, g, b = p, q, v
			elseif i == 4 then r, g, b = t, p, v
			elseif i == 5 then r, g, b = v, p, q
			end
			return Color3.new(r, g, b)
		end

		local function RGBToHSV(color)
			local r, g, b = color.R, color.G, color.B
			local maxc = math.max(r, g, b)
			local minc = math.min(r, g, b)
			local v = maxc
			local d = maxc - minc
			local s = maxc == 0 and 0 or d / maxc
			local h = 0
			if maxc == minc then h = 0
			elseif maxc == r then h = (g - b) / d + (g < b and 6 or 0)
			elseif maxc == g then h = (b - r) / d + 2
			elseif maxc == b then h = (r - g) / d + 4
			end
			h = h / 6
			return h, s, v
		end

		function items:AddColorPicker(text, defaultColor, callback)
			defaultColor = defaultColor or Color3.fromRGB(255,255,255)
			local wrap = make("Frame", {Size = UDim2.new(1,-16,0,140), BackgroundTransparency = 1, Parent = items})
			local label = make("TextLabel", {Text = text, BackgroundTransparency = 1, TextColor3 = Luma.Theme.PrimaryText, Font = Enum.Font.Gotham, TextSize = 14, Position = UDim2.new(0,8,0,6), Parent = wrap})
			local preview = make("Frame", {Size = UDim2.new(0,42,0,42), Position = UDim2.new(1,-50,0,6), BackgroundColor3 = defaultColor, Parent = wrap})
			make("UICorner", {Parent = preview, CornerRadius = UDim.new(0,6)})

			local h, s, v = RGBToHSV(defaultColor)
			-- Hue slider (0-1)
			local hueSlider = items:AddSlider("Hue", 0, 1, h, function(val)
				h = val
				local col = HSVToRGB(h, s, v)
				preview.BackgroundColor3 = col
				if callback then pcall(callback, col) end
			end)

			-- Saturation slider (0-1)
			local satSlider = items:AddSlider("Saturation", 0, 1, s, function(val)
				s = val
				local col = HSVToRGB(h, s, v)
				preview.BackgroundColor3 = col
				if callback then pcall(callback, col) end
			end)

			-- Value slider (0-1)
			local valSlider = items:AddSlider("Value", 0, 1, v, function(val)
				v = val
				local col = HSVToRGB(h, s, v)
				preview.BackgroundColor3 = col
				if callback then pcall(callback, col) end
			end)

			return {Preview = preview, Get = function() return preview.BackgroundColor3 end}
		end

		return items
	end

	return tab
end

-- Simple notification utility
function Luma:Notify(title, text, time)
	playSound("NotifyShow")
	-- queued notify to avoid overlapping
	self._notifyQueue = self._notifyQueue or {}
	table.insert(self._notifyQueue, {title = title, text = text, time = time or 3})
	if self._notifyRunning then return end
	self._notifyRunning = true
	while #self._notifyQueue > 0 do
		local item = table.remove(self._notifyQueue, 1)
		local nt = item.time or 3
		local notif = make("Frame", {Size = UDim2.new(0,300,0,70), BackgroundColor3 = Color3.fromRGB(28,28,33), AnchorPoint = Vector2.new(1,0), Position = UDim2.new(1,16,0,16), Parent = self.ScreenGui, BackgroundTransparency = 1})
		make("UICorner", {Parent = notif, CornerRadius = UDim.new(0,8)})
		local t = make("TextLabel", {Text = item.title, BackgroundTransparency = 1, TextColor3 = Luma.Theme.PrimaryText, Font = Enum.Font.GothamBold, TextSize = 16, Position = UDim2.new(0,12,0,8), Parent = notif})
		local d = make("TextLabel", {Text = item.text, BackgroundTransparency = 1, TextColor3 = Luma.Theme.SecondaryText, Font = Enum.Font.Gotham, TextSize = 13, Position = UDim2.new(0,12,0,30), Parent = notif})
		-- animate slide-in from right and fade
		notif.Position = UDim2.new(1, 320, 0, 16)
		notif.BackgroundTransparency = 1
		tween(notif, {Position = UDim2.new(1,-16,0,16), BackgroundTransparency = 0}, 0.36, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
		-- subtle content fade
		d.TextTransparency = 1
		t.TextTransparency = 1
		tween(d, {TextTransparency = 0}, 0.36)
		tween(t, {TextTransparency = 0}, 0.36)
		task.delay(nt, function()
			tween(notif, {Position = UDim2.new(1, 320, 0, 16), BackgroundTransparency = 1}, 0.28, Enum.EasingStyle.Sine, Enum.EasingDirection.In)
			task.delay(0.28, function() if notif and notif.Parent then notif:Destroy() end end)
		end)
		-- wait for the duration + animation time before showing next
		local waitTime = nt + 0.7
		local s = 0
		while s < waitTime do s = s + task.wait(0.1) end
	end
	self._notifyRunning = false
end

-- Theme setter
function Luma:SetTheme(theme)
	for k,v in pairs(theme) do
		Luma.Theme[k] = v
	end
	-- Apply immediate changes to existing UI
	if self and self.Main then
		self.Main.BackgroundColor3 = Luma.Theme.Background
		self.Title.TextColor3 = Luma.Theme.PrimaryText
	end
end

-- Animate theme transition across all UI elements in this ScreenGui
function Luma:AnimateTheme(newTheme, time)
	time = time or 0.35
	-- merge newTheme into Luma.Theme
	for k,v in pairs(newTheme) do Luma.Theme[k] = v end
	if not self or not self.ScreenGui then return end
	-- Traverse descendants and tween color properties where applicable
	for _, inst in pairs(self.ScreenGui:GetDescendants()) do
		local ok, _ = pcall(function()
			if inst:IsA("Frame") or inst:IsA("ImageLabel") or inst:IsA("ImageButton") then
				if inst.BackgroundColor3 then
					tween(inst, {BackgroundColor3 = Luma.Theme.Background}, time)
				end
			end
			if inst:IsA("TextLabel") or inst:IsA("TextButton") or inst:IsA("TextBox") then
				if inst.TextColor3 then
					tween(inst, {TextColor3 = Luma.Theme.PrimaryText}, time)
				end
			end
			-- accent for UIStroke or fill frames named 'Accent' if present
			if inst.Name:lower():find("accent") then
				if inst:IsA("Frame") and inst.BackgroundColor3 then
					tween(inst, {BackgroundColor3 = Luma.Theme.Accent}, time)
				end
			end
		end)
	end
end

-- Modal dialog helper
function Luma:OpenModal(title, text, buttons)
	playSound("ModalOpen")
	-- buttons: array of {Text = string, Callback = function}
	if not self or not self.ScreenGui then return end
	local overlay = make("Frame", {Size = UDim2.new(1,0,1,0), BackgroundColor3 = Color3.fromRGB(0,0,0), BackgroundTransparency = 0.6, Parent = self.ScreenGui})
	overlay.ZIndex = 1000
	local modal = make("Frame", {Size = UDim2.new(0,420,0,160), BackgroundColor3 = Luma.Theme.Background, AnchorPoint = Vector2.new(0.5,0.5), Position = UDim2.new(0.5,0,0.5,0), Parent = overlay})
	make("UICorner", {Parent = modal, CornerRadius = UDim.new(0,10)})
	local titleLbl = make("TextLabel", {Text = title or "", BackgroundTransparency = 1, TextColor3 = Luma.Theme.PrimaryText, Font = Enum.Font.GothamBold, TextSize = 18, Position = UDim2.new(0,16,0,12), Parent = modal})
	local textLbl = make("TextLabel", {Text = text or "", BackgroundTransparency = 1, TextColor3 = Luma.Theme.SecondaryText, Font = Enum.Font.Gotham, TextSize = 14, Position = UDim2.new(0,16,0,44), Size = UDim2.new(1,-32,0,60), TextWrapped = true, Parent = modal})
	local btnFrame = make("Frame", {Size = UDim2.new(1,0,0,44), Position = UDim2.new(0,0,1,-44), BackgroundTransparency = 1, Parent = modal})
	local layout = make("UIListLayout", {Parent = btnFrame, FillDirection = Enum.FillDirection.Horizontal, HorizontalAlignment = Enum.HorizontalAlignment.Right, Padding = UDim.new(0,8)})
	for i = #buttons,1,-1 do
		local b = buttons[i]
		local btn = make("TextButton", {Text = b.Text or "Ok", Size = UDim2.new(0,88,0,32), BackgroundColor3 = Color3.fromRGB(34,34,38), TextColor3 = Luma.Theme.PrimaryText, Parent = btnFrame})
		make("UICorner", {Parent = btn, CornerRadius = UDim.new(0,6)})
		btn.MouseButton1Click:Connect(function()
			-- animate out then call
			tween(overlay, {BackgroundTransparency = 1}, 0.22)
			tween(modal, {Position = UDim2.new(0.5,0,0.5,20), BackgroundTransparency = 1}, 0.22)
			task.delay(0.22, function() overlay:Destroy() end)
			if b.Callback then pcall(b.Callback) end
		end)
	end
	-- animate in
	overlay.BackgroundTransparency = 1
	modal.Position = UDim2.new(0.5,0,0.5,-20)
	tween(overlay, {BackgroundTransparency = 0.6}, 0.22)
	tween(modal, {Position = UDim2.new(0.5,0,0.5,0)}, 0.26, Enum.EasingStyle.Back)
	return overlay
end

-- Helper to quickly load code from a URL (if your executor supports HttpGet and loadstring)
function Luma:LoadURL(url)
	if not url then return end
	local ok, res = pcall(function()
		local http = game:GetService("HttpService")
		-- Many executors use game:HttpGet; this helper will try both
		local body
		if syn and syn.request then
			local r = syn.request({Url = url, Method = "GET"})
			body = r.Body
		else
			body = (game.HttpGet and game:HttpGet(url)) or ""
		end
		if body and body ~= "" then
			local chunk = loadstring or load
			if chunk then
				local fn = chunk(body)
				if type(fn) == "function" then
					return fn()
				end
			end
		end
	end)
	return ok and res or nil
end

-- Return Luma library (module-like)
-- Settings helpers (export/import)
Luma.Settings = {}
local HttpService = game:GetService("HttpService")

function Luma:ExportSettings()
	local ok, res = pcall(function()
		return HttpService:JSONEncode(self.Settings or {})
	end)
	return ok and res or nil
end

function Luma:ImportSettings(json)
	if not json then return false end
	local ok, tbl = pcall(function() return HttpService:JSONDecode(json) end)
	if ok and type(tbl) == "table" then
		self.Settings = tbl
		return true
	end
	return false
end

function Luma:SetSetting(key, value)
	self.Settings = self.Settings or {}
	self.Settings[key] = value
end

function Luma:GetSetting(key, default)
	self.Settings = self.Settings or {}
	return self.Settings[key] ~= nil and self.Settings[key] or default
end

-- Persistence helpers
function Luma:SaveToFile(filename)
	if not writefile then return false, "writefile not available in this environment" end
	local json = self:ExportSettings()
	if not json then return false, "no settings to save" end
	writefile(filename, json)
	return true
end

function Luma:LoadFromFile(filename)
	if not readfile then return false, "readfile not available" end
	if not isfile(filename) then return false, "file missing" end
	local content = readfile(filename)
	local ok = self:ImportSettings(content)
	return ok
end

-- DataStore template (works in server scripts; provided as helper stub)
function Luma:SaveToDataStore(key)
	-- This is a template: DataStoreService is only available in server context.
	local ok, err = pcall(function()
		local ds = game:GetService("DataStoreService"):GetDataStore("LumaSettings")
		ds:SetAsync(key, self.Settings or {})
	end)
	return ok
end

function Luma:LoadFromDataStore(key)
	local ok, res = pcall(function()
		local ds = game:GetService("DataStoreService"):GetDataStore("LumaSettings")
		return ds:GetAsync(key)
	end)
	if ok and type(res) == "table" then
		self.Settings = res
		return true
	end
	return false
end

-- Tooltip helper
function Luma:MakeTooltip(parent, text)
	if not parent or not text then return end
	local tip = make("TextLabel", {Text = text, BackgroundColor3 = Color3.fromRGB(20,20,25), TextColor3 = Luma.Theme.PrimaryText, Font = Enum.Font.Gotham, TextSize = 12, Visible = false, Parent = parent})
	make("UICorner", {Parent = tip, CornerRadius = UDim.new(0,6)})
	tip.AnchorPoint = Vector2.new(0,1)
	tip.Position = UDim2.new(0,0,0,0)
	parent.MouseEnter:Connect(function()
		tip.Visible = true
		tween(tip, {Position = UDim2.new(0,0,0,-6)}, 0.12)
	end)
	parent.MouseLeave:Connect(function()
		tween(tip, {Position = UDim2.new(0,0,0,0)}, 0.12)
		task.delay(0.12, function() tip.Visible = false end)
	end)
	return tip
end

-- Theme presets
Luma.ThemePresets = {
	Default = Luma.Theme,
	Vanta = {Background = Color3.fromRGB(18,18,22), Accent = Color3.fromRGB(98,0,238), PrimaryText = Color3.fromRGB(240,240,240), SecondaryText = Color3.fromRGB(150,150,160), WindowCorner = UDim.new(0,10)},
	Ocean = {Background = Color3.fromRGB(10,25,35), Accent = Color3.fromRGB(0,170,200), PrimaryText = Color3.fromRGB(230,240,245), SecondaryText = Color3.fromRGB(160,180,190), WindowCorner = UDim.new(0,10)},
}

function Luma:AddThemePreset(name, theme)
	if not name or type(theme) ~= "table" then return end
	Luma.ThemePresets[name] = theme
end

function Luma:ApplyPreset(name)
	local p = Luma.ThemePresets[name]
	if not p then return false end
	self:SetTheme(p)
	return true
end

return Luma
